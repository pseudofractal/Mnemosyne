LLM OPERATING INSTRUCTIONS
================================================================
You are looking at a *complete*, authoritative description of a source-code project.  Never guess; if data are not in this file, they do not exist.

Top-level keys
--------------
• "project_name"        – repo root folder name, human readable.
• "env"                 – { "os", "arch", "generated_at" } runtime metadata.
• "files"               – ordered array of file objects (see below).
• "dependency_graph"    – `{ "path": ["dep1", "dep2"] }` built from Rust `use` statements; use as a DAG for traversal.
• "directory_tree"      – pre-rendered ASCII tree; quick visual map only.
• "ignored_files"       – glob patterns that were *excluded* during the scan.

File object
-----------
{
  "path":     "relative path from repo root",
  "language": "rs" | "py" | …,          // lowercase extension
  "bytes":    <int>,                    // raw file size in bytes
  "tokens":   <int>,                    // rough whitespace-split count
  "code":     "<source lines ending with ⧉<n> markers>"
}


Line-number marker
------------------
Each line in files[i].code ends with the character “⧉” (U+29C9) followed by its
1-based line number.  Any runner **must strip** this trailer before compiling or
executing; it is *not* a language comment.
Before compiling or running, remove the “⧉<n>” trailer at EOL.
  • awk:   awk '{sub(/⧉[0-9]+$/, ""); print}' old_file > new_file
  • Python: clean = re.sub(r"⧉\d+$", "", line)
  • Rust (regex crate):
        let re = Regex::new(r"⧉\d+$").unwrap();
        let clean = re.replace(&line, "");
Any equivalent regex that matches U+29C9 followed by digits to end-of-line is fine.


Required reasoning workflow
---------------------------
1. Build a map `{path → file}` from *files[]* for O(1) lookup; verify `sha256` if integrity matters.
2. Traverse code in dependency order: topologically sort *dependency_graph* or start at obvious entry points (`src/cli.rs`, `main.go`, etc.).
3. For any code citation, reference **exact** ranges: `src/lib.rs:141-180` and quote only the needed lines from the relevant chunk.
4. Keep your context window lean: use *tokens* to decide when to summarise rather than inline large chunks.  
5. If a path matches *ignored_files*, treat it as off-limits—even if some snippet elsewhere mentions it.  
6. When tool APIs are available (search, compile, run, test), prefer them over speculation.  State clearly which tool you are invoking and why.  
7. Traverse this json file programatically, when needed to find the contents of a file. Do not check up your context, always generate the file prgramatically.

Output style checklist
----------------------
✓ No hallucination: stay strictly within provided data.  
✓ Be concise, technical, and skeptical.  
✓ Cite code with `path:line-line`.  
✓ Summaries before details; details on demand.  
✓ If you cannot answer, say so explicitly.

End of instructions.

